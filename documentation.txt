 require Documentation
 ------- -------------
 require: "Ensure APL objects are in the current namespace or ⎕PATH; else loads them
           from a workspace (*.dws) or *.dyalog files."
   Syntax 1:   list1 list2     ← [[stdLib] CODE∊1 0 ¯1] ∇  package1 [package2 [... packageN]]
               namespaceRef    ←  [stdLib] CODE:2 ¯2    ∇  ...
      namespaceRef list1 list2 ←  [stdLib] CODE:4 ¯4    ∇  ...
   Syntax 2:   namespaceRef    ←  [stdLib]              ∇  [⍬ | '']
   Syntax 3:   ⍬               ←                        ∇  '-HELP'
________________________________________________________________________________________

 Syntax 1:
 ---------
     "Given names of packages:
         APL objects, namespaces/directories and objects, or
         workspaces (optionally with namespaces and objects),
     look in the current directory, the ⎕PATH, and on disk in directories set in ⎕SE.∆WSPATH,
     for those packages and, if not in the active workspace, copy them from the disk
     or workspace  into the library specified as the stdLib."
   ∘ package formats:
           [wsN:][dir.]name |  [wsN:]
   ∘ stdLib is a namespace reference or name (existing or to be created).
     '' implies <top>, the top-level in which require's caller operates, either # or ⎕SE.
   ∘ If missing, stdLib is <top>.⍙⍙.require (top as above).
   ∘ ⎕LIB as a prefix to stdLib is <top>.⍙⍙.require, useful with setting subdirectories,
     e.g. '⎕LIB.math' is  '#.⍙⍙.require.math' if require's caller is in # or subdirectory.
   ∘ Updates caller's ⎕PATH to provide access to the packages, dropping any
     path namespaces that don't exist. ⎕PATH only ensures functions and operators
     are found. See Syntax 2 for how to specify a library, e.g. to access a class etc.
   ∘ CODE is optional and may be 1 or 0.
     If 0 (default), returns as below (Ia) or (IIa).
   ∘ For the disk path, <require> searches as follows:
       a. Use ⎕SE.∆WSPATH, if present. If not,
       b. Use (OS X) environment variable WSPATH. Else
       c. Use string '.' (current directory based on ]CD)
     Each item must be a string indicating absolute or relative file directories
     (if absent, they are ignored) separated by colons (:).
   ∘ An empty package generates an error.
   ---------------------------------------
   ∘ Returns elements from:  stdLibR list1  list2
     ∘ If CODE<0, DEBUG is set to 1 and CODE←|CODE. CODE of 0 is treated as if 1.
     Ia. CODE=1   Returns  list1 list2   (success: shy; some failures: non-shy)
       list1:  lists 0 or more successful <package msg> pairs.
       list2:  lists 0 or more <package msg> pairs that were not successfully found and/or ⎕FIXed.
       Shy response if list2 is empty (all packages loaded or already in ⎕PATH).
       Nonshy response if list2 is not empty (at least one package was not found or not ⎕FIXed).
     Ib. CODE=2   Returns   stdLibR   or ⎕SIGNAL's failure
       Scan for and load all packages as above; then
       return only the <library ns ref> on success, otherwise ⎕SIGNAL's a failure.
       - NOTE that if you use multiple libraries, or if a package was put in the ⎕PATH
         by other means, then the std library returned may not be where the package is located.
     Ic. CODE=4   Returns   stdLibR list1 list2  (success: shy; some failures: non-shy)
       Scan for and load all packages as above; then
       return on success OR failure
            <library ns ref> list1 list2

 Syntax 2: Right arg has length 0 (⍬ or '')
 ------------------------------------------
   ∘ Returns a reference to the specified or default standard library (stdLib).
     IIa. CODE∊0 1 2 is ignored.  No searching or loading is expected or done.
       E.g. if mathPack is a class, one might "require" it this way:
          require 'mathPack'
       then access it this way:
          myMath ← ⎕NEW (require '').mathPack
  -------------------------------------------
  ∘  Returns: namespaceRef
     The namespace reference for the specified or default library.

 Syntax 3: Right argument is '-HELP'
 -----------------------------------
   ∘ Displays help information (from require/documentation.txt).
____________________________________________________________________________________________

 Search: What is searched to find each package?
          package      what's searched
          ¯¯¯¯¯¯¯¯¯¯   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
          name         caller NS, ⎕PATH ns, in $WSPATH, but not workspaces.
          dir.name     same as 'name', but search for dir.name of any complexity (a.b.c.d).
          wsN:name      caller ns, ⎕PATH ns, workspace wsN: for name, in $WSPATH.
          wsN:dir.name  caller ns, ⎕PATH ns, workspace wsN:, in $WSPATH for dir.name of any complexity.
          wsN:          workspace <wsN>, copying everything.
_____________________________________________________________________________________________
