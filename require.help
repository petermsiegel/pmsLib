 require Documentation
 ------- -------------
 require:  Ensure specified APL objects are in the calling function's or operator's namespace or ⎕PATH; 
           else loads them from a workspace (*.dws) or from  dyalog files. The objects are specified
           by name alone, namespace and name, or workspace, namespace, and name, e.g.
               [ws:]ns1.[ns2.ns3.]name, 
           which, during a disk search is treated as a search for:
               ns1/[ns2/ns3/]name/*.dyalog  AND  ns1/[ns2/ns3/]name.dyalog 

   Syntax 1:   list1 list2     ← [[stdLib] CODE∊1 0 ¯1] ∇  package1 [package2 [... packageN]]
               namespaceRef    ←  [stdLib] CODE:2 ¯2    ∇  ...
      namespaceRef list1 list2 ←  [stdLib] CODE:4 ¯4    ∇  ...
   Syntax 2:   namespaceRef    ←  [stdLib]              ∇  [⍬ | '']
   Syntax 3:   ⍬               ←                        ∇  '-HELP'
________________________________________________________________________________________

 Syntax 1: Verify or load packages, update ⎕PATH
           Right arg is a list of packages (each a string)
----------------------------------------------------------
     "Given names of packages:
         APL objects, namespaces/directories and objects, or
         workspaces (optionally with namespaces and objects),
     look in the current directory, the ⎕PATH, and on disk in directories set in ⎕SE.∆WSPATH,
     for those packages and, if not in the active workspace, copy them from the disk
     or workspace  into the library specified as the stdLib."
   ∘ package formats:
           [wsN:][dir.]name |  [wsN:]
   ∘ stdLib is a namespace reference or name (existing or to be created).
     '' implies a reference to <top>, the top-level in which require's caller operates, either # or ⎕SE.
   ∘ If missing, stdLib is <top>.⍙⍙.require (top as above).
   ∘ ⎕LIB as a prefix to stdLib is <top>.⍙⍙.require, useful with setting subdirectories,
     e.g. '⎕LIB.math' is  '#.⍙⍙.require.math' if require's caller is in # or subdirectory.
   ∘ Updates caller's ⎕PATH to provide access to the packages, dropping any
     path namespaces that don't exist. ⎕PATH only ensures functions and operators
     are found. See Syntax 2 for how to specify a library, e.g. to access a class etc.
   ∘ CODE is optional and may be 1 (or 0), 2, or 4 or (DEBUG info provided) -1 -2 or -4. 
     If 1 or -1, returns as below (Ia) or (IIa). See below for CODE, DEBUG.
   ∘ For the disk path, <require> searches as follows:
       a. Use ⎕SE.∆WSPATH, if present. If not,
       b. Use (OS X) environment variable WSPATH. Else
       c. Use string '.' (current directory based on ]CD)
     Each item must be a string indicating absolute or relative file directories
     (if absent, they are ignored) separated by colons (:).
   ∘ An empty package generates an error.
   ---------------------------------------
   ∘ Returns elements from:  stdLibR list1  list2
     ∘ If CODE<0, DEBUG is set to 1 and CODE←|CODE. CODE of 0 is treated as if 1.
     Ia. CODE=1   Returns  list1 list2   (success: shy; some failures: non-shy)
       list1:  lists 0 or more successful <package msg> pairs.
       list2:  lists 0 or more <package msg> pairs that were not successfully found and/or ⎕FIXed.
       Shy response if list2 is empty (all packages loaded or already in ⎕PATH).
       Nonshy response if list2 is not empty (at least one package was not found or not ⎕FIXed).
     Ib. CODE=2   Returns   stdLibR   or ⎕SIGNAL's failure
       Scan for and load all packages as above; then
       return only the <library ns ref> on success, otherwise ⎕SIGNAL's a failure.
       - NOTE that if you use multiple libraries, or if a package was put in the ⎕PATH
         by other means, then the std library returned may not be where the package is located.
     Ic. CODE=4   Returns   stdLibR list1 list2  (success: shy; some failures: non-shy)
       Scan for and load all packages as above; then
       return on success OR failure
            <library ns ref> list1 list2

 Syntax 2: Return reference to the standard library
           Right argument is ⍬
---------------------------------------------------
   ∘ Returns a reference to the specified or default standard library (stdLib).
     IIa. CODE∊0 1 2 is ignored.  No searching or loading is expected or done.
       E.g. if mathPack is a class, one might "require" it this way:
          require 'mathPack'
       then access it this way:
          myMath ← ⎕NEW (require '').mathPack
  -------------------------------------------
  ∘  Returns: namespaceRef
     The namespace reference for the specified or default library.

 Syntax 3: Help information. 
           Right argument is '-HELP'
 -----------------------------------
   ∘ Displays help information (from require/documentation.txt).
____________________________________________________________________________________________

 Search: What is searched to find each package?

  package          searched for what...  where (>> means "and then")
  ¯¯¯¯¯¯¯¯¯¯     ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
  name             name                  in CALLER >> PATH >> WSPATH (but no workspaces)   
  dir.name         dir.name, name        (SAME)
  WSNAME:name      name                  CALLER >> PATH >> WSNAME (via ⎕CY)             
  WSNAME:dir.name  dir.name              CALLER >> PATH >> WSNAME (via ⎕CY)
  WSNAME:          WSNAME                WSNAME itself in WSPATH (via ⎕CY)

  CALLER: the caller's namespace (*)
  PATH:   the namespaces in ⎕PATH
  WSPATH: the directories in WSPATH
  WSNAME: the named workspace
  * For speed, CALLER is searched first, then PATH, before checking directories or workspaces!
_______________________________________________________________________________________________
